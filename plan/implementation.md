# MemoGarden Budget - Implementation Plan

## Overview

Building a lightweight personal expenditure capture and review system with two main components:
- **memogarden-core**: Flask backend with SQLite
- **memogarden-budget**: Flutter app (web + Android)

**Tech Stack:**
- Backend: Python 3.13 with Flask (synchronous)
- Database: SQLite (no ORM, raw SQL)
- Frontend: Flutter
- Package Manager: Poetry with poetry-plugin-shell
- Deployment: Local dev first, later Raspberry Pi/Railway with gunicorn

**Repositories:**
- Core: https://github.com/memogarden/memogarden-core
- Budget: https://github.com/memogarden/memogarden-budget (to be created)

---

## Implementation Steps

### Step 1: Core Backend Foundation ⚡ CURRENT STEP

Establish the foundational backend API with SQLite database, transaction CRUD operations, and testing infrastructure.

#### 1.1 Project Setup & Structure ✅ COMPLETED

**Objective:** Initialize repository with Python project structure and minimal dependencies.

**Status:** Complete (commit: 4bfbbe0)

**Substeps:**

##### 1.1.1 Clone and Initialize Repository ✅
- Clone `memogarden-core` from GitHub
- Navigate to `/home/kureshii/memogarden/memogarden-core`
- Initialize git if needed, ensure clean working directory

##### 1.1.2 Set Up Python Environment ✅

##### 1.1.3 Install Core Dependencies ✅
Add to `pyproject.toml`:
```toml
[tool.poetry.dependencies]
python = "^3.13"
flask = "^3.0.0"
gunicorn = "^21.2.0"
pydantic = "^2.5.0"
pydantic-settings = "^2.1.0"
python-dotenv = "^1.0.0"

[tool.poetry.group.dev.dependencies]
pytest = "^7.4.0"
pytest-flask = "^1.3.0"
ruff = "^0.1.0"
```

**Architecture Note:** Initially implemented with async FastAPI + aiosqlite, but refactored to synchronous Flask + built-in sqlite3 for simplicity. For a personal knowledge system with low traffic, deterministic synchronous execution is preferred over async complexity.

##### 1.1.4 Create Directory Structure ✅
```
memogarden-core/
├── memogarden_core/
│   ├── __init__.py
│   ├── main.py
│   ├── config.py
│   ├── database.py
│   ├── db/
│   │   ├── __init__.py
│   │   ├── schema.sql
│   │   └── migrations/
│   ├── schemas/
│   │   ├── __init__.py
│   │   └── transaction.py
│   ├── api/
│   │   ├── __init__.py
│   │   └── v1/
│   │       ├── __init__.py
│   │       ├── transactions.py
│   │       └── labels.py
│   └── utils/
│       └── __init__.py
├── tests/
│   ├── __init__.py
│   ├── conftest.py
│   └── api/
│       └── test_transactions.py
├── data/
│   └── .gitignore
├── .env.example
├── .gitignore
├── README.md
└── pyproject.toml
```

##### 1.1.5 Configure Environment ✅
  ```
  DATABASE_PATH=./data/memogarden.db
  API_V1_PREFIX=/api/v1
  CORS_ORIGINS=["http://localhost:3000"]
  DEFAULT_CURRENCY=SGD
  ```

**Deliverables:** ✅ All delivered

---

#### 1.2 SQLite Database Schema ✅ COMPLETED

**Objective:** Design and implement SQLite schema with global entity registry and transactions table. Accounts and categories are simple labels (user-defined strings), not entities with their own lifecycle.

**Status:** Complete - Refactored to synchronous Flask + sqlite3

**Architecture Decision:** Use global entity registry to store common metadata (lifecycle, grouping, supersession) separate from type-specific attributes. This enables:
- Easy addition of new entity types
- Common metadata in one place (no duplication)
- Cross-entity queries and relationships
- Type lookup without prefix mapping

**Substeps:**

##### 1.2.1 Design Schema ✅
Create `memogarden_core/db/schema.sql` with complete DDL:

```sql
-- Schema Version: 20251223
-- Base Schema: memogarden-core-v1
-- Description: Initial schema with entity registry and transactions
--
-- Schema Philosophy:
-- - Global entity registry stores common metadata for all entity types
-- - Type-specific tables store only domain attributes
-- - Accounts and categories are labels (simple TEXT), not relational entities
-- - Schema version tracked in _schema_metadata for migration tracking
-- - Fresh databases apply current schema; existing databases migrate forward-only
-- - After successful migration, schema snapshots archived to Soil for agent reference

-- Schema metadata table (for version tracking and migration management)
CREATE TABLE IF NOT EXISTS _schema_metadata (
    key TEXT PRIMARY KEY,
    value TEXT NOT NULL,
    updated_at TEXT NOT NULL
);

INSERT INTO _schema_metadata VALUES
    ('version', '20251223', datetime('now')),
    ('base_schema', 'memogarden-core-v1', datetime('now')),
    ('description', 'Initial schema with entity registry and transactions', datetime('now'));

-- Global entity registry (common metadata for ALL entity types)
CREATE TABLE IF NOT EXISTS entity (
    id TEXT PRIMARY KEY,              -- Plain UUID (generated by Python)
    type TEXT NOT NULL,               -- Entity table name: 'transactions', 'recurrences', etc.
    group_id TEXT,                    -- Optional grouping/clustering of related entities
    superseded_by TEXT,               -- Reclassification: points to superseding entity
    superseded_at TEXT,               -- ISO 8601 timestamp of supersession
    derived_from TEXT,                -- Provenance: points to source entity
    created_at TEXT NOT NULL,         -- ISO 8601 timestamp
    updated_at TEXT NOT NULL,         -- ISO 8601 timestamp

    FOREIGN KEY (group_id) REFERENCES entity(id),
    FOREIGN KEY (superseded_by) REFERENCES entity(id),
    FOREIGN KEY (derived_from) REFERENCES entity(id)
);

CREATE INDEX IF NOT EXISTS idx_entity_type ON entity(type);
CREATE INDEX IF NOT EXISTS idx_entity_created ON entity(created_at);
CREATE INDEX IF NOT EXISTS idx_entity_superseded ON entity(superseded_by);
CREATE INDEX IF NOT EXISTS idx_entity_group ON entity(group_id);

-- Transactions table (domain-specific attributes only)
CREATE TABLE IF NOT EXISTS transactions (
    id TEXT PRIMARY KEY,
    amount REAL NOT NULL,
    currency TEXT NOT NULL DEFAULT 'SGD',
    transaction_date TEXT NOT NULL,  -- ISO 8601 date (YYYY-MM-DD)
    description TEXT NOT NULL DEFAULT '',  -- Short title (e.g., "Coffee at Starbucks")
    account TEXT NOT NULL,            -- Label: e.g., "Household", "Personal"
    category TEXT,                    -- Label: e.g., "Food", "Transport"
    author TEXT NOT NULL DEFAULT 'system',
    recurrence_id TEXT,               -- FK to entity (type='recurrences')
    notes TEXT,                       -- Optional longer details

    FOREIGN KEY (id) REFERENCES entity(id) ON DELETE CASCADE,
    FOREIGN KEY (recurrence_id) REFERENCES entity(id)
);

-- Indexes for query performance
CREATE INDEX IF NOT EXISTS idx_transactions_date ON transactions(transaction_date);
CREATE INDEX IF NOT EXISTS idx_transactions_account ON transactions(account);
CREATE INDEX IF NOT EXISTS idx_transactions_category ON transactions(category);

-- Convenient view for querying transactions with metadata
CREATE VIEW IF NOT EXISTS transactions_view AS
SELECT
    t.*,
    e.created_at,
    e.updated_at,
    e.superseded_by,
    e.superseded_at,
    e.group_id,
    e.derived_from
FROM transactions t
JOIN entity e ON t.id = e.id;
```

##### 1.2.2 Implement Database Connection Layer ✅
Create `memogarden_core/database.py`:
- `def get_db() -> sqlite3.Connection` - connection factory
- `def init_db()` - runs schema.sql, creates tables (for fresh databases)
- `def get_schema_version() -> str` - reads version from _schema_metadata
- `def close_db()` - cleanup connection
- Uses built-in sqlite3 module (no async)

**Entity Registry Helper Functions:**
- `def create_entity(db, entity_type: str, entity_id: str | None = None) -> str` - Insert into entity registry, return UUID
- `def get_entity_type(db, entity_id: str) -> str` - Lookup entity type from registry
- `def supersede_entity(db, old_id: str, new_id: str)` - Mark entity as superseded

**Note:** Migration framework (for existing database upgrades) deferred to Step 3+

##### 1.2.3 Create Seed Data Script ✅
Create `memogarden_core/db/seed.py`:
- 10-15 sample transactions across different dates
- Each transaction includes: description (short title), amount, account, category, notes
- Using account labels: "Household", "Personal"
- Using category labels: "Food", "Transport", "Shopping", "Entertainment", "Utilities", "Healthcare"
- Example descriptions: "Coffee at Starbucks", "Grocery shopping", "Taxi to airport", etc.
- Mix of recent dates (last 30 days)
- Use entity registry pattern: create entity first, then transaction
- CLI command: `poetry run python -m memogarden_core.db.seed`

**Deliverables:** ✅ All delivered
- `schema.sql` with complete DDL including `entity` registry and `_schema_metadata` table
- `database.py` with connection management, `get_schema_version()`, and entity helper functions
- Seed script for development data using entity registry pattern
- Database initialization working
- Schema version tracking in place (foundation for future migrations)
- Entity registry functioning with type lookup
- Comprehensive test suite ensuring all invariants (23 tests passing)
- **Refactored from async (FastAPI + aiosqlite) to sync (Flask + sqlite3)** for simplicity

---

#### 1.3 Pydantic Schemas (API Validation) ✅ COMPLETED

**Objective:** Define Pydantic models for API request/response validation.

**Status:** Complete - All schemas implemented with comprehensive tests

**Substeps:**

##### 1.3.1 Transaction Schemas ✅
Create `memogarden_core/schemas/transaction.py`:
```python
from datetime import date, datetime
from pydantic import BaseModel, Field

class TransactionBase(BaseModel):
    amount: float
    currency: str = "SGD"
    transaction_date: date
    description: str                  # Short title (e.g., "Coffee at Starbucks")
    account: str                      # Label, not FK
    category: str | None = None       # Label, not FK
    notes: str | None = None          # Optional longer details

class TransactionCreate(TransactionBase):
    """Request body for creating a transaction"""
    pass

class TransactionUpdate(BaseModel):
    """Request body for updating a transaction (all fields optional)"""
    amount: float | None = None
    currency: str | None = None
    transaction_date: date | None = None
    description: str | None = None
    account: str | None = None
    category: str | None = None
    notes: str | None = None

class TransactionResponse(TransactionBase):
    """API response with transaction + entity metadata"""
    id: str
    author: str
    recurrence_id: str | None = None
    created_at: datetime              # From entity registry
    updated_at: datetime              # From entity registry
    superseded_by: str | None = None  # From entity registry
    group_id: str | None = None       # From entity registry
```

**Note:** Use Query() parameters directly for list filtering (no separate Pydantic model needed for <6 params)

**Deliverables:** ✅ All delivered
- Complete Pydantic schemas for transactions (4 schemas: Base, Create, Update, Response)
- Request/response models separated and well-documented
- Response includes entity registry metadata (created_at, updated_at, superseded_by, superseded_at, group_id, derived_from)
- Description field for human-readable transaction titles
- Accounts and categories as string labels (no FK constraints)
- Modern Pydantic V2 syntax with ConfigDict
- Comprehensive test suite (18 tests for schema validation)
- All tests passing (41 total tests)

---

#### 1.4 Flask Application & Configuration ✅ COMPLETED

**Objective:** Set up Flask application with CORS, error handling, and configuration management.

**Status:** Complete - Flask app fully configured with CORS, error handling, logging, and request context database pattern

**Note:** Using Flask (synchronous) instead of FastAPI (async) for simplicity.

**Substeps:**

##### 1.4.1 Create Configuration Module ✅
- Configuration module already existed from Step 1.1
- Uses pydantic-settings for environment variable management
- Settings include: database_path, api_v1_prefix, cors_origins, default_currency

##### 1.4.2 Initialize Flask Application ✅
Updated `memogarden_core/main.py`:
- Flask app created with CORS configured via flask-cors package
- Database initialization runs once on app startup (with app context)
- Smart init_db() checks if database exists before applying schema
- Health check endpoint at `/health` returns `{"status": "ok"}`
- Database teardown handler registered for per-request connection cleanup

##### 1.4.3 Create Error Handling ✅
Created `memogarden_core/exceptions.py` and updated `memogarden_core/main.py`:
- Custom exception classes: `MemoGardenError` (base), `ResourceNotFound`, `ValidationError`, `DatabaseError`
- All exceptions support message and optional details dict
- Error handlers for 404 (not found), 400 (validation), 500 (internal)
- Consistent JSON error responses with `error.type`, `error.message`, and optional `error.details`
- Logging configuration with INFO level and structured format

##### 1.4.4 Update Database Pattern for Flask ✅
Updated `memogarden_core/database.py`:
- Migrated from global connection to Flask request context pattern
- `get_db()` now uses Flask's `g` object for per-request connections
- `close_db()` teardown handler automatically closes connections after each request
- Foreign keys enabled on all connections
- Thread-safe and follows Flask best practices

**Deliverables:** ✅ All delivered
- Settings management with environment variables (Step 1.1)
- Flask app with CORS configured (flask-cors)
- Database initialization on startup (idempotent)
- Request context pattern for database connections (Flask `g` object)
- Error handling middleware with custom exceptions in separate module
- Health check endpoint working
- Logging configured at INFO level
- **73 tests passing** (16 app tests, 15 error tests, 5 config tests, 20 database tests, 18 schema tests, 3 health tests, plus existing tests)
- Flask server tested and verified running

---

#### 1.5 API Endpoints Implementation ✅ COMPLETED

**Objective:** Implement CRUD endpoints for transactions, plus utility endpoints for listing distinct labels.

**Status:** Complete (commit: pending)

**Architecture Note:** Label endpoints nested under transactions resource for better REST hierarchy. Accounts and categories are UI-side enumerations; these endpoints provide lookup convenience.

**Substeps:**

##### 1.5.1 Transactions API (Core Feature)
Create `memogarden_core/api/v1/transactions.py`:

**Endpoints:**
- `POST /api/v1/transactions` - Create transaction
  - Generate UUID
  - Create entity in registry (type='transactions')
  - Insert transaction data
  - Use database transaction for atomicity
  - Return created transaction with metadata

- `GET /api/v1/transactions/{id}` - Get single transaction
  - Join transactions with entity registry
  - Include metadata (created_at, superseded_by, etc.)
  - Return 404 if not found

- `GET /api/v1/transactions` - List with filtering
  - Query params: `start_date`, `end_date`, `account`, `category`, `limit`, `offset`
  - Join with entity registry for metadata
  - Build dynamic WHERE clause
  - Filter out superseded transactions by default (optional include_superseded flag)
  - Return paginated results

- `PUT /api/v1/transactions/{id}` - Update transaction
  - Validate transaction exists
  - Update only provided fields in transactions table
  - Update `updated_at` in entity registry
  - Return updated transaction with metadata

- `DELETE /api/v1/transactions/{id}` - Delete transaction
  - Hard delete from transactions table
  - CASCADE deletes from entity registry
  - (Soft delete via supersession deferred to deltas feature)

- `GET /api/v1/transactions/accounts` - List distinct account labels
  - Returns array of unique account strings from transactions
  - Useful for UI autocomplete

- `GET /api/v1/transactions/categories` - List distinct category labels
  - Returns array of unique category strings from transactions
  - Useful for UI autocomplete

##### 1.5.2 Implement Database Queries
For each endpoint, write raw SQL queries:
- Use parameterized queries (prevent SQL injection)
- Handle UUID generation (use Python `uuid.uuid4()`)
- Entity registry pattern: INSERT into entity first, then type-specific table
- Join transactions with entity for reads
- ISO 8601 timestamp formatting for dates
- Proper error handling and validation
- Use database transactions for multi-table operations

**Example transaction creation:**
```python
entity_id = str(uuid4())
now = datetime.utcnow().isoformat()

async with db.cursor() as cursor:
    # Insert into entity registry
    await cursor.execute(
        "INSERT INTO entity (id, type, created_at, updated_at) VALUES (?, 'transactions', ?, ?)",
        (entity_id, now, now)
    )
    # Insert into transactions table
    await cursor.execute(
        "INSERT INTO transactions (id, amount, ...) VALUES (?, ?, ...)",
        (entity_id, data.amount, ...)
    )
    await db.commit()
```

**Deliverables:** ✅ All delivered
- Working CRUD endpoints for transactions (POST, GET, PUT, DELETE)
- Label utility endpoints for accounts and categories
- Proper request/response validation with Pydantic
- Database queries using sqlite3 (synchronous) with entity registry pattern
- Entity metadata included in all responses
- Error handling (404, 400, 500)
- **21 comprehensive API tests** (all passing)
- **Total: 94 tests passing**

---

#### 1.6 Testing Infrastructure

**Objective:** Set up pytest with async support and write comprehensive tests for API endpoints.

**Substeps:**

##### 1.6.1 Configure Pytest
Create `pytest.ini`:
```ini
[pytest]
asyncio_mode = auto
testpaths = tests
python_files = test_*.py
python_classes = Test*
python_functions = test_*
```

Create `tests/conftest.py`:
```python
import pytest
import aiosqlite
from httpx import AsyncClient
from memogarden_core.main import app
from memogarden_core.database import init_db

@pytest.fixture
async def test_db():
    """Create test database"""
    # Use in-memory database for tests
    async with aiosqlite.connect(":memory:") as db:
        await init_db(db)
        yield db

@pytest.fixture
async def client(test_db):
    """Create test client"""
    async with AsyncClient(app=app, base_url="http://test") as ac:
        yield ac
```

##### 1.6.2 Write Transaction Tests
Create `tests/api/test_transactions.py`:
- `test_create_transaction()` - POST creates transaction
- `test_get_transaction()` - GET retrieves by ID
- `test_get_transaction_not_found()` - 404 for missing ID
- `test_list_transactions()` - GET list returns array
- `test_list_transactions_with_date_filter()` - filter by date range
- `test_list_transactions_with_account_filter()` - filter by account label
- `test_list_transactions_with_category_filter()` - filter by category label
- `test_update_transaction()` - PUT updates fields including labels
- `test_delete_transaction()` - DELETE removes transaction
- `test_create_transaction_invalid_data()` - validation errors

##### 1.6.3 Write Label Utility Tests
Create `tests/api/test_labels.py`:
- `test_list_account_labels()` - GET returns distinct accounts
- `test_list_category_labels()` - GET returns distinct categories
- `test_labels_empty_database()` - Returns empty arrays when no transactions

##### 1.6.4 Run Tests and Achieve Coverage
- Run: `poetry run pytest`
- Check coverage: `poetry run pytest --cov=memogarden_core`
- Target: >80% coverage for API endpoints and database layer

**Deliverables:**
- Pytest configured with async support
- Test fixtures for database and HTTP client
- Comprehensive test suite (>80% coverage)
- All tests passing

---

#### 1.6.5 Design Schema Extension Mechanisms

**Objective:** Define how to extend the schema while maintaining forward compatibility and enabling reconcilable drift between users.

**Substeps:**

##### 1.6.5.1 Define Compatibility Rules

Document in `docs/schema-compatibility.md`:

**Base Schema Compatibility:**
- Base schema version (e.g., `memogarden-core-v1`) must match
- Required fields must exist in all versions
- Optional extensions can vary between users
- Agents declare minimum base schema version they require

**Field Addition Rules:**
- New optional fields: backward compatible (older agents ignore)
- New required fields: requires base schema version bump
- Field type changes: requires migration

**Extension Mechanism:**
- Track extensions in `_schema_metadata` (JSON array)
- Example: `["custom-fields", "tags", "attachments"]`
- Agents check for required extensions before operating

##### 1.6.5.2 Document Migration Philosophy

**Migration Principles:**
- Forward-only (no rollbacks; bugfixes are new migrations)
- Fresh databases apply current schema (no replay)
- Existing databases apply pending migrations from `core/db/migrations/`
- After successful migration:
  - Schema snapshot archived to `soil/core-migration/snapshots/YYYYMMDD-description.sql`
  - Migration archived to `soil/core-migration/migrations/YYYYMMDD-NNN-description.sql`
  - Migration removed from core (or moved to `migrations/applied/`)

**Version Format:** `YYYYMMDD` (e.g., `20251223`)
- Simple, chronological, date-based
- Migration number suffix if multiple per day: `YYYYMMDD-NN`

##### 1.6.5.3 Prepare for Future Migration Framework

**Document (but don't implement yet):**

Migration runner requirements:
```python
async def migrate():
    """Apply pending migrations to existing database"""
    db_version = await get_schema_version()
    pending = list_pending_migrations()  # From core/db/migrations/

    for migration in pending:
        if migration.version > db_version:
            await apply_migration(migration)
            await archive_to_soil(migration)
            await update_schema_version(migration.version)
```

Soil archiving interface:
```python
async def archive_to_soil(migration):
    """Archive migration and schema snapshot to Soil"""
    # Write schema snapshot to soil/core-migration/snapshots/
    # Write migration SQL to soil/core-migration/migrations/
    # Soil is S3-compatible bucket or FUSE filesystem
```

**Note:** Actual implementation deferred to Step 3 (when first migration is needed)

**Deliverables:**
- Schema compatibility rules documented
- Migration philosophy documented
- Extension mechanism designed (tracked in `_schema_metadata`)
- Foundation for future migration framework (no code yet)

---

#### 1.7 Documentation & Development Workflow

**Objective:** Create documentation and ensure smooth local development experience.

**Substeps:**

##### 1.7.1 Write README.md
Create comprehensive README with:
- Project overview and architecture
- Prerequisites (Python 3.11+, Poetry)
- Installation steps
- Running locally: `poetry run uvicorn memogarden_core.main:app --reload`
- Running tests: `poetry run pytest`
- Database setup and seed data
- API documentation link (Swagger UI at `/docs`)
- Environment variables reference

##### 1.7.2 Document API
- FastAPI auto-generates OpenAPI docs at `/docs`
- Add docstrings to all endpoint functions
- Add example requests/responses in docstrings
- Document query parameters and response schemas

##### 1.7.3 Create Development Scripts
Add to `pyproject.toml`:
```toml
[tool.poetry.scripts]
dev = "uvicorn memogarden_core.main:app --reload"
seed = "memogarden_core.db.seed:main"
test = "pytest"
```

##### 1.7.4 Validate End-to-End Workflow
- Fresh clone → Poetry install → Seed data → Run server → Test API
- Document any gotchas or setup issues
- Ensure reproducible development environment

**Deliverables:**
- Complete README with setup instructions
- API documentation accessible at `/docs`
- Development scripts for common tasks
- Validated end-to-end developer experience

---

#### 1.8 Step 1 Completion Checklist

**Success Criteria:**
- [ ] API server runs locally: `poetry run uvicorn memogarden_core.main:app --reload`
- [ ] Database schema created from `schema.sql`
- [ ] Seed data loads successfully
- [ ] All CRUD endpoints working:
  - [ ] Create transaction via POST
  - [ ] Retrieve transaction by ID via GET
  - [ ] List transactions with date/account/category filtering
  - [ ] Update transaction via PUT
  - [ ] Delete transaction via DELETE
  - [ ] Label utility endpoints (list distinct accounts/categories)
- [ ] Tests passing with >80% coverage
- [ ] API docs accessible at `http://localhost:8000/docs`
- [ ] README complete with setup instructions
- [ ] `.env.example` documented

**Deliverables:**
✅ Working REST API with transaction CRUD
✅ SQLite database with schema (no ORM)
✅ Pydantic schemas for API validation
✅ Test suite with good coverage
✅ Clear setup documentation
✅ Seed data for local development
✅ FastAPI with async/await throughout

---

### Step 2: Authentication & Multi-User Support

**Objective:** Add user management, JWT authentication, and API key support for agents.

**Components:**
- User table and registration
- JWT-based authentication for Budget app
- API key authentication for agent access
- Author tracking from auth context
- Permission model (user vs agent vs admin)
- Middleware for auth on protected endpoints

**Deliverables:**
- User registration and login endpoints
- JWT token generation and validation
- API key management
- Protected endpoints with auth middleware
- Author automatically set from context

---

### Step 3: Advanced Core Features

**Objective:** Implement recurrences, relations, and delta tracking.

**Components:**

#### 3.1 Recurrences
- Create `recurrences` table (id, rrule, entities, valid_from, valid_until)
- iCal rrule parsing library integration
- Recurrence template → transaction generation
- CRUD endpoints for recurrences
- UI in Budget app for managing recurring transactions

#### 3.2 Relations
- Create `relations` table (id, core_id, ref_id, ref_type, notes, created_at, revoked_on)
- Note: No core_type field needed - entity registry provides type lookup for core_id
- Link any Core entity to Soil artifacts or other entities
- CRUD endpoints for relations
- Support multiple relation types (source, reconciliation, supersedes, occurs_at, occurs_during, other)

#### 3.3 Deltas (Audit Log)
- Create `deltas` table (id, entity_type, entity_id, field, old_value, new_value, rationale, author, timestamp)
- Emit deltas on all mutations (INSERT/UPDATE/DELETE)
- Delta tracking middleware/decorator
- Query endpoints for audit history

**Deliverables:**
- Recurrence system with iCal compatibility
- Relation management for document links
- Complete audit trail via deltas
- API endpoints for all three features

---

### Step 4: Flutter App Foundation

**Objective:** Initialize Budget app with basic UI and API integration.

**Components:**
- Create `memogarden-budget` repository
- Flutter project setup (web + Android)
- Project structure (clean architecture or feature-based)
- HTTP client for Core API
- State management (Riverpod or Provider)
- Navigation structure
- Design system (colors, typography, components)

**Screens:**
- Transaction capture screen (Monefy-inspired)
- Transaction list screen
- Settings screen

**Deliverables:**
- Flutter app running on web and Android
- API client connected to Core
- Basic transaction creation flow
- Simple, fast UI (<5 second capture goal)

---

### Step 5: Budget App Features

**Objective:** Complete Budget app with spending review and management features.

**Components:**

#### 5.1 Spending Review
- Daily spending view (list grouped by date)
- Monthly summary with category breakdown
- Yearly overview with trends
- Charts/visualizations (optional, defer if complex)

#### 5.2 Account & Category Management
- Account selection during transaction creation
- Category picker with icons
- Manage accounts (create, edit, delete)
- Manage categories (create, edit, delete)

#### 5.3 Transaction Management
- Edit transaction screen
- Delete transaction with confirmation
- Transaction detail view
- Search/filter transactions

#### 5.4 Recurring Transactions UI
- Create recurring transaction template
- View upcoming recurring transactions
- Mark occurrence as completed/skipped

**Deliverables:**
- Complete spending review interface
- Account and category management
- Full transaction CRUD in UI
- Recurring transaction interface

---

### Step 6: Agent Integration & Deployment

**Objective:** Enable agent workflows and prepare for production deployment.

**Components:**

#### 6.1 Agent Workflows
- Statement reconciliation endpoint
- Email parsing integration (with Soil)
- Transaction suggestion API
- Bulk operations for agents
- Reconciliation status tracking

#### 6.2 Testing & CI/CD
- Integration tests for full workflows
- E2E tests for critical paths
- GitHub Actions for CI
- Automated testing on PR

#### 6.3 Deployment
- Docker configuration for Core API
- Docker Compose for local full-stack
- Railway deployment configuration
- Raspberry Pi deployment guide
- Environment variable management
- Database backup strategy

#### 6.4 Documentation
- API documentation for agents
- Agent integration guide
- Deployment runbook
- Troubleshooting guide

**Deliverables:**
- Agent-ready API endpoints
- CI/CD pipeline
- Production deployment configurations
- Complete documentation

---

## Key Principles

### Database Philosophy
- **SQLite as source of truth**: Schema.sql defines reality, Pydantic validates API
- **Global entity registry**: Common metadata (lifecycle, grouping, supersession) stored in `entity` table, type-specific attributes in dedicated tables
- **Plain UUIDs**: Entity IDs are standard UUID4 strings (no prefixes), type stored in registry
- **UTC everywhere**: All timestamps in UTC ISO 8601 format
- **Day-level dates**: Transaction dates are DATE (YYYY-MM-DD), not timestamps
- **No ORM**: Raw SQL queries with aiosqlite for control and simplicity
- **Entity creation pattern**: Two-step process - create entity in registry, then insert type-specific data
- **Schema versioning**: Tracked in `_schema_metadata`, enables migration tracking
- **Forward-only migrations**: Bugfixes are new migrations, no rollbacks
- **Reconcilable drift**: Users may have different schema versions, base compatibility maintained
- **Soil archiving**: Schema history preserved in Soil for agent reference and data archaeology
- **Referential integrity**: Foreign keys enforce valid entity references and enable cascade operations

### API Philosophy
- **RESTful conventions**: Standard HTTP methods and resource URLs
- **Versioning**: `/api/v1/` prefix for future compatibility
- **Rich filtering**: Query parameters for common operations
- **Pagination ready**: Limit/offset from the start
- **Consistent responses**: Standard JSON structure

### Development Philosophy
- **Minimal dependencies**: Only add what's needed
- **Local-first**: Everything runs without external services
- **Test early**: Tests written alongside features
- **Document as you go**: README and docstrings updated incrementally
- **Incremental delivery**: Each step delivers working software

---

## Critical Files Reference

### Step 1 Critical Files
- `/home/kureshii/memogarden/plan/prd.md` - Requirements source of truth
- `memogarden-core/memogarden_core/db/schema.sql` - Database schema (source of truth)
- `memogarden-core/memogarden_core/database.py` - Database connection layer
- `memogarden-core/memogarden_core/api/v1/transactions.py` - Core transaction API
- `memogarden-core/memogarden_core/schemas/transaction.py` - API validation models
- `memogarden-core/pyproject.toml` - Dependencies and project config
- `memogarden-core/README.md` - Setup and development guide

---

## Risk Mitigation

### Technical Risks
- **SQLite limitations**: Single-writer, but acceptable for personal use
- **Async/await complexity**: Mitigated by using aiosqlite consistently
- **UUID handling**: Use TEXT type, generate in Python layer
- **Date/time handling**: Strict ISO 8601, UTC only, document clearly

### Scope Risks
- **Feature creep**: Stick to plan, defer nice-to-haves
- **Premature optimization**: No caching, no complex queries until needed
- **Over-engineering auth**: Start simple, add OAuth later if needed

### Deployment Risks
- **Minimal dependencies**: Easier to deploy anywhere
- **SQLite portability**: Database is a single file
- **Configuration**: Environment-based for flexibility

---

## Implementation Sequence Rationale

**Step 1 (Core Backend)** comes first because:
- Backend is single source of truth
- API contract defines all interactions
- Can validate data model in isolation
- Easy to test without UI dependencies

**Step 2 (Auth)** comes after Core because:
- Core CRUD validated first
- Auth affects all endpoints, easier to add after basics work
- Can test with "system" author initially

**Step 3 (Advanced Features)** deferred because:
- Recurrences, relations, deltas are complex
- Not needed for basic transaction capture
- Can learn from Step 1 & 2 experience

**Step 4-5 (Flutter)** come after stable API because:
- Need stable API contract first
- Backend can be tested independently
- Reduces rework from API changes

**Step 6 (Agents & Deployment)** last because:
- Most complex workflows
- Depends on all core features
- Can defer without blocking user value

---

## Next Actions

**Step 1.1 Complete** ✅ (commit: 4bfbbe0)
**Step 1.2 Complete** ✅ (refactored to sync Flask + sqlite3, all tests passing)
**Step 1.3 Complete** ✅ (Pydantic schemas with comprehensive tests)
**Step 1.4 Complete** ✅ (Flask app with CORS, error handling, logging, request context pattern - 73 tests passing)
**Step 1.5 Complete** ✅ (API Endpoints Implementation - 94 tests passing)

**Currently on:** Ready for Step 1.6 or proceed to Step 2 (Authentication & Multi-User Support)

### Step 1.5 Summary
**Completed:**
- Created [memogarden_core/api/v1/transactions.py](memogarden-core/memogarden_core/api/v1/transactions.py) with 7 endpoints
- Registered blueprint in [main.py](memogarden-core/memogarden_core/main.py)
- 21 comprehensive API tests covering all endpoints
- All 94 tests passing

**Endpoints implemented:**
- `POST /api/v1/transactions` - Create transaction
- `GET /api/v1/transactions` - List with filtering (date, account, category, pagination)
- `GET /api/v1/transactions/{id}` - Get single transaction
- `PUT /api/v1/transactions/{id}` - Update transaction (partial updates supported)
- `DELETE /api/v1/transactions/{id}` - Delete transaction
- `GET /api/v1/transactions/accounts` - List distinct account labels
- `GET /api/v1/transactions/categories` - List distinct category labels

**Next immediate tasks (choose one):**
1. **Step 1.6:** Design Schema Extension Mechanisms (deferred, can skip for now)
2. **Step 1.7:** Documentation & Development Workflow
3. **Step 2:** Authentication & Multi-User Support
4. **Commit** Step 1.5 changes to git

### Recommended Next Step
Step 1.6 (Schema Extension Mechanisms) can be deferred since we haven't needed migrations yet. Proceed to **Step 1.7: Documentation & Development Workflow** to complete the foundation before moving to Step 2 (Authentication).
